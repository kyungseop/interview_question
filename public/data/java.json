[
  {
    "quiz": "Optional 이란?",
    "answer": "존재할 수도 있지만 안 할 수도 있는 객체”, 즉, “null 이 될 수도 있는 객체”을 감싸고 있는 일종의 래퍼 클래스",
    "ref": "https://nesoy.github.io/articles/2018-06/Java-volatile"
  },
  {
    "quiz": "volatile 키워드에 대해 설명",
    "answer": "Main Memory에 read & write를 보장하는 키워드. 하나의 Thread가 write하고 나머지 Thread가 읽는 상황인 경우나 변수의 값이 최신의 값으로 읽어와야 하는 경우 사용. CPU Cache 보다 Main Memory 가 비용이 더 크기 때문에 변수 값 일치을 보장해야 하는 경우에만 volatile 사용하는 것이 좋음. 여러 Thread가 write하는 상황에서는 적합하지 않음."
  },
  {
    "quiz": "Class Constructor에서 Exception을 발생시킬 때 어떤 현상이 일어나는가?",
    "answer": ""
  },
  {
    "quiz": "자바와 C++메모리 관리 차이",
    "answer": ""
  },
  {
    "quiz": "람다란?",
    "answer": ""
  },
  {
    "quiz": "Stream API 활용",
    "answer": ""
  },
  {
    "quiz": "JVM 메로리 구조",
    "answer": ""
  },
  {
    "quiz": "멀티쓰레드 상황에서 String Intern append 하는 것과 StringBuffer를 이용하는 것의 차이점",
    "answer": ""
  },
  {
    "quiz": "singleton 이란 무엇인지 설명하고, 싱글턴으로 만드는 방식과 설명",
    "answer": "인스턴스를 오직 하나만 생성할 수 있는 클래스. public static final 필드 방식의 싱글턴, 정적 팩토리 방식의 싱글턴, 열거 타입 방식의 싱글턴"
  },
  {
    "quiz": "equals 매서드는 정의하는게 좋은가?",
    "answer": "꼭 필요한 경우가 아니면 equals 를 재정의하지 말자. 많은 경우에 Object 의 equals 가 원하는 비교를 정확히 수행해준다"
  },
  {
    "quiz": "equals 메서드 구현 방법. 어떻게 구현하면 되는가?",
    "answer": "== 연산자를 사용해 입력이 자기 자신의 참조인지 확인. instanceOf 연산자로 입력이 올바른 타입인지 확인. 입력을 올바른 타입으로 형변환. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사"
  },
  {
    "quiz": "equals 메서드 구현 주의사항",
    "answer": "재정의할 땐 hashCode 도 반드시 재정의. Object 외의 타입을 매개변수로 받는 equals 메서드는 선언금지"
  },
  {
    "quiz": "raw 타입인 List와 List<Object>의 차이는?",
    "answer": "List 는 제네릭 타입에서 완전히 발을 뺀 것이고, List<Object>는 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이다. 매개변수로 List 를 받는 메서드에 List<String>을 넘길 수 있지만, List<Object>를 받는 메서드에는 넘길 수 없다. 이는 제네릭의 하위 타입 규칙 때문. 즉, List<String>은 raw 타입인 List의 하위 타입이지만, List<Object>의 하위 타입은 아니다. 그 결과 List<Object>와 같은 매개변수화 타입을 사용할 때와 달리 List 같은 raw 타입을 사용하면 타입 안전성을 잃게 된다."
  },
  {
    "quiz": "Set<?>와 raw 타입인 Set의 차이는 무엇일까?",
    "answer": "와일드카드 탕입은 안전하고, raw 타입은 안전하지 않다. raw 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다. 반면 Collection<?>에는 (null외에는) 어떤 원소도 넣을 수 없다."
  },
  {
    "quiz": "자바의 데이터 타입인 기본형",
    "answer": "정수형 - byte, short, int, long \n 실수형 - double, float \n bool형 - boolean 각 데이터 형간에는 형변환이 가능하며, 큰 값에서 작은 값으로 캐스팅 시에는 값 손실이 있으므로, 반드시 (데이터형)을 표기하고 형변환 하여야 함"
  },
  {
    "quiz": "자바의 데이터 타입인 reference Type",
    "answer": "기본형을 제외한 나머지 모두가 reference Type. 데이터 타입과는 달리, 참조값을 통해 해당 객체에 직접적으로 접근할 수 있음"
  },
  {
    "quiz": "가상함수, Overriding 차이",
    "answer": "요거랍니다."
  },
  {
    "quiz": "접근 제어자의 종류와 특성에 대해 설명하시오",
    "answer": "Public (어디서든 접근이 가능), Default (같은 패키지 내 혹은 상속 받은 클래스 내에서 접근 가능), Protected (같은 패키지 내에서만 접근 가능), Private (같은 클래스 내에서만 접근 가능)"
  },
  {
    "quiz": "프로세스와 스레드란?",
    "answer": "프로세스 -  실행되고 있는 프로그램의 개체. CPU 시간이나 메모리 등 시스템 장원이 할당되는 독립적인 개체. 다른 프로세스와 상관 없이 독립적으로 자원을 할당 받음.프로세스 간의 통신을 위해선 파이프, 파일, 소켓 등을 사용하여 통신하여야 함쓰레드 - 프로세스 안에 존재하여, 프로세스의 자원을 공유하는 개체흔히 경량 프로세스라고 부름. 각 쓰레드는 별도의 레지스터와 스택을 갖고, 힙 영역은 공유함"
  },
  {
    "quiz": "뮤텍스",
    "answer": "프로세스 혹은 쓰레드 간의 통신 시에 shared memory 등을 쓰는 경우 하나의 자원에 두 개 이상의 프로세스 혹은 쓰레드가 접근하는 경우에 문제가 발생. 이를 제어하기 위해 쓰레드에서는 뮤텍스를 사용. 상호배제라고도 하며, Critical Section을 가진 스레드의 Running time이 서로 겹치지 않도록 각각 단독으로 실행하게 하는 기술. synchronized 또는 lock을 통해 해결"
  },
  {
    "quiz": "세마포어",
    "answer": " 프로세스에서 사용. 리소스 상태를 나타내는 간단한 카운터. 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할 수 있음."
  },
  {
    "quiz": "쓰레드를 구현하기 위한 방법",
    "answer": "1.Runnable 인터페이스 구현.- run 함수를 반드시 구현해야 함, Thread 생성자의 매개변수로 입력. 2. Thread 클래스를 상속 - Thread 클래스를 상속 받아서 구현. 자바는 다중 상속이 안되므로 이외의 클래스를 상속 받을 수 없음"
  },
  {
    "quiz": "synchronized에 대해 설명",
    "answer": "쓰레드가 하나의 자원을 공유함에 따라 데이터 일관성의 문제가 생기는데, synchronized 처리를 해줌으로써, 하나의 쓰레드만 접근할 수 있도록 함."
  },
  {
    "quiz": "Static 키워드",
    "answer": "인스턴스 변수 혹은 인스턴스 메소드를 클래스 변수 혹은 클래스 메소드로 변경시킴. 모든 인스턴스 간에 공유하는 변수 혹은 메소드가 됨"
  },
  {
    "quiz": "클래스와 인스턴스의 차이",
    "answer": "클래스는 빵을 찍어 내는 틀과 같고, 인스턴스는 빵. 클래스에서 정해진 기능과 모양에 맞추어 인스턴스가 생성됨"
  },
  {
    "quiz": "객체지향",
    "answer": "개발하려는 기능을 묶어 모듈화, 모듈을 재활용하기 때문에 같은 기능을 반복적으로 연산하지 않고 재사용률이 높음. 업그레이드가 쉬위며, 디버깅이 쉬움. 절차 지향에 비해 상대적으로 느림"
  },
  {
    "quiz": "절차지향",
    "answer": "순차적인 처리가 중요시 됩니다. 프로그램 전체가 유기적으로 연결되어 있어 하나의 코드 변경이 전체에 영향을 미칠 수 있음. 코드 사이즈를 최소화하고, 가장 빠르게 동작하는게 우선이면 절차지향 프로그래밍 언어를 사용"
  },
  {
    "quiz": "자바와 C의 차이점",
    "answer": "자바는 One Source, Multi use 소스 하나를 가지고, 자바를 설치할 수 있는 플랫폼이라면 어떤 플랫폼에서도 소스 변경없이 사용 가능. 메모리 관리를 JVM 내 GC를 통해 이루어지므로 시스템 안정성이 높음자동으로 해주는 만큼 성능이 떨어지는 단점이 있음."
  },
  {
    "quiz": "캡슐화",
    "answer": "객체 외부에서 개채 내부 정보를 직접 접근하거나 조작할 수 없고, 외부에서 접근할 수 있도록 정의된 메소드를 통해서만 관련 데이터에 접근할 수 있음. 내부 정보가 은폐되어 변경이 발생할 때 오류 발생이 적으며, 재사용이 용이함 "
  },
  {
    "quiz": "상속",
    "answer": "이미 작성된 클래스를 이어 받아, 새로운 클래스를 생성하는 기법. 코드의 재활용성이 커짐"
  },
  {
    "quiz": "다형성",
    "answer": "하나의 객체가 여러 개의 자료형 타입을 가질 수 있는 특성"
  },
  {
    "quiz": "추상클래스와",
    "answer": "클래스 앞에 abstract가 붙으며, 실제 메소드 추가도 가능. 상속 받은 클래스에서 구현을 강제하지 않음"
  },
  {
    "quiz": "인터페이스",
    "answer": "클래스가 아닌, 다른 구조체 사용(interface). 다중 상속이 가능하며, 구현을 명시한 클래스에서는 반드시 구현해야 함"
  },
  {
    "quiz": "전역/클래스 변수",
    "answer": "모든 인스턴스가 공통된 영역을 공유함. 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 경우에 클래스 변수로 선언"
  },
  {
    "quiz": "인스턴스 변수",
    "answer": "클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어짐. 인스턴스는 독립적인 저장공간을 가지므로 인스턴스 별로 서로 다른 값을 가질 수 있음"
  },
  {
    "quiz": "지역 변수",
    "answer": "메서드 내에 선언되며, 메서드 내에서만 사용가능. 메서드가 종료되면 소멸되는 변수"
  },
  {
    "quiz": "변수 초기화 순서",
    "answer": "클래스 변수 -> 인스턴스 변수 -> 지역 변수"
  },
  {
    "quiz": "변수 저장 영역",
    "answer": "Method Area - 클래스에 대한 데이터와 클래스 변수 저장. Heap - 인스턴스가 생성되는 공간, 인스턴스의 정보들을 저장. 호출 스택 - 메서드의 작업에 필요한 메모리 공간을 제공, 메소드가 종료되면 할당되었던 메모리 공간이 반환됨"
  },
  {
    "quiz": "오버로딩과 오버라이딩의 차이",
    "answer": "오버로딩 - 똑같은 함수에 매개변수를 변경하여 선언. 오버라이딩 - 부모 클래스로 부터 상속 받은 메소드의 내부 구현 로직을 변경"
  },
  {
    "quiz": "자바 제너릭이란?",
    "answer": "프로그래머가 의도하지 않은 객체가 저장될 수 없더록 타입을 지정하는 것"
  },
  {
    "quiz": "컴파일러",
    "answer": "프로그램 단위 번역, 전체 번역 후 수행, 효율성 높음. 저장소 많이 필요"
  },
  {
    "quiz": "인터프리터",
    "answer": "명령 줄 단위로 번영, 줄 단위로 번역 수행, 번역 후 즉시 수행, 효율성 낮음. 저정도 적게 필요"
  },
  {
    "quiz": "리팩토링이란",
    "answer": "중복된 메서드를 하나로 합치고, 이동하는 것을 말함"
  },
  {
    "quiz": "instanceOf 명령어",
    "answer": "특정 객체가 특정 클래스의 객체 인지 확인할 때 사용하는 내부 명령어"
  }
]